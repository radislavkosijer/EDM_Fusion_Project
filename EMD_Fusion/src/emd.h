/*****************************************************************************
 * emd.h
 *
 * Created on: January 20, 2025.
 * Author: Radislav Kosijer
 *
 * @brief Header file for Empirical Mode Decomposition (EMD) and image processing.
 *****************************************************************************/

#ifndef EMD_H
#define EMD_H

#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include "led.h"

/** @brief Maximum signal length (width * height). */
#define MAX_SIGNAL_LEN (200 * 200)

/** @brief Maximum number of extrema per signal. */
#define MAX_EXTREMA 1024

/** @brief Window size for variance calculation. */
#define WINDOW_SIZE 3

/** @brief Decision threshold (epsilon) for image fusion. */
#define EPSILON 10

/*==============================================================================
 * Function Declarations
 *============================================================================*/

/**
 * @brief Perform Empirical Mode Decomposition (EMD) on a signal.
 *
 * This function decomposes the input signal into its intrinsic mode functions (IMFs).
 *
 * @param signal Pointer to the signal data in Q16.16 fixed-point format.
 * @param length Length of the signal.
 */
void emd_decompose(int32_t* signal, int length);

/**
 * @brief Calculate the local variance of an image using a sliding window.
 *
 * This function computes the local variance for each pixel of the input image (in Q16.16 format)
 * using a square window (e.g., 3x3).
 *
 * @param imf         Pointer to the input image.
 * @param width       Image width.
 * @param height      Image height.
 * @param variance_map Output array to store the computed variance.
 */
void calculate_local_variance(const int32_t* imf, int width, int height, int32_t* variance_map);

/**
 * @brief Generate a decision mask based on the variance maps of two images.
 *
 * The decision mask is generated by comparing the local variances of two images.
 *
 * @param var_map1  Variance map for the first image.
 * @param var_map2  Variance map for the second image.
 * @param width     Image width.
 * @param height    Image height.
 * @param alpha_mask Output array for the decision mask.
 */
void generate_decision_mask(const int32_t* var_map1, const int32_t* var_map2, int width, int height, char* alpha_mask);

/**
 * @brief Fuse two images based on a decision mask.
 *
 * This function fuses two 8-bit images according to the provided decision mask.
 *
 * @param imgA       Pointer to the first image data.
 * @param imgB       Pointer to the second image data.
 * @param alpha_mask Decision mask determining pixel selection.
 * @param width      Image width.
 * @param height     Image height.
 * @param fused_img  Output array to store the fused image.
 */
void fuse_images(const unsigned char* imgA, const unsigned char* imgB, const char* alpha_mask, int width, int height, unsigned char* fused_img);

/**
 * @brief Convert an 8-bit image to Q16.16 fixed-point format.
 *
 * @param input  Pointer to the input 8-bit image.
 * @param output Pointer to the output image in Q16.16 format.
 * @param size   Number of pixels in the image.
 */
void convert_to_q16_16(const unsigned char* input, int32_t* output, int size);

/**
 * @brief Convert a Q16.16 fixed-point image to 8-bit format.
 *
 * This function converts the fixed-point representation back to an 8-bit image,
 * applying appropriate rounding and clamping.
 *
 * @param input  Pointer to the input image in Q16.16 format.
 * @param output Pointer to the output 8-bit image.
 * @param size   Number of pixels in the image.
 */
void convert_from_q16_16(const int32_t* input, unsigned char* output, int size);

/**
 * @brief Perform linear interpolation using SIMD for envelope calculation.
 *
 * This internal function interpolates between extrema points in a signal using linear interpolation.
 *
 * @param extrema_pos  Array of positions of extrema.
 * @param extrema_val  Array of values at the extrema.
 * @param num_extrema  Number of extrema.
 * @param envelope     Output envelope array.
 * @param signal_length Length of the signal.
 */
static void linear_interp_simd(const int32_t* extrema_pos, const int32_t* extrema_val,
                               int num_extrema, int32_t* envelope, int signal_length);

/**
 * @brief Perform linear histogram stretching on an 8-bit grayscale image.
 *
 * This function scans the image to find the minimum and maximum pixel values,
 * and then linearly stretches all pixel values to cover the full range [0..255].
 * If all pixels have the same value, no stretching is applied.
 *
 * @param img    Pointer to the input 8-bit grayscale image.
 * @param width  Image width.
 * @param height Image height.
 */
void histogram_stretch(unsigned char* img, int width, int height);

#endif /* EMD_H */
